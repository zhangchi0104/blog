[{"content":"LeetCode-2130 核心思路 利用tow pointer (fast/slow) 来寻找中点。 fast pointer 每次forward两个node 找到中点后翻转任意半条list，同时forward两个pointer求每对pair的和。取最大值 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def pairSum(self, head: Optional[ListNode]) -\u0026gt; int: fast = slow = head prev = None slow_next = None # Progress forward (2 nodes each iter) # So when it reaches the end, the slow # pointer is in the middle of the kist while fast and fast.next: fast = fast.next.next ## Each time slow proceeds, # reverse the connection # 5-\u0026gt;4 become 4-\u0026gt;5 slow_next = slow.next slow.next = prev prev = slow slow = slow_next right = slow left = prev ans = 0 # traverse through 2 partitions # compute sum for each pair while right: left_val = left.val right_val = right.val tmp = left_val + right_val if tmp \u0026gt; ans: ans = tmp left = left.next right = right.next return ans ","date":"0001-01-01T00:00:00Z","image":"https://blog.otakuma.dev/p/leetcode-2130/cover_hue56f229207cc922027401a38662f60be_139567_120x120_fill_box_smart1_3.png","permalink":"https://blog.otakuma.dev/p/leetcode-2130/","title":"LeetCode-2130"},{"content":"Leetcode-290 (Word Pattern) 难度为easy, 也不用考虑什么算法，就一个for loop搞定。\n核心思路 pattern中的字母与所提供的字符串s 中的单词为一一对应的关系，所以同是便利两个字符串即可，如果有与当前对应关系不匹配的单词，则提前返回False，否则则在便利完成后返回True即可。\n踩坑 python dict 所表达的是many to one关系，即一个value可对应多个key。第一次提交时没有意识到这个问题， fail了一个test case。\n1 2 3 4 5 Input: pattern = \u0026#34;abba\u0026#34; s = \u0026#34;dog dog dog dog\u0026#34; Output: True Expbected: False 解决的方法也很简单， 多添加一个 set用来记录已知单词，其实也可以用mappings.values()，不过会慢一点， 但是不需要额外的内存 （理论上讲）。\n代码 (Python3) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution: def wordPattern(self, pattern: str, s: str) -\u0026gt; bool: # 如果长度不匹配则提前返回 False if len(pattern) != s.count(\u0026#34; \u0026#34;) + 1: return False # 初始化数据结构用于表达one to one mapping mappings = {} known_words = set() # 同时便利pattern 和 s for word, label in zip(s.split(), pattern): known_word = mappings.get(label, None) if not known_word: # 如果需要把新label分配给已知的单词 # 提前返回False if word in known_words: return False # 添加到mapping中 mappings[label] = word known_words.add(word) # 不匹配则提前返回 elif word != known_word: return False return True ","date":"0001-01-01T00:00:00Z","image":"https://blog.otakuma.dev/p/leetcode-290/cover_hue56f229207cc922027401a38662f60be_139567_120x120_fill_box_smart1_3.png","permalink":"https://blog.otakuma.dev/p/leetcode-290/","title":"Leetcode-290 (Word Pattern)"}]